#DPATCHLEVEL=0
# Reorder the event_thread again, because it's more logical.
--- src/libxosd/xosd.c~	2004-09-02 20:43:17.000000000 +0200
+++ src/libxosd/xosd.c	2004-09-02 20:55:30.000000000 +0200
@@ -231,9 +231,9 @@ draw_text(xosd * osd, int line)
  * This is running in it's own thread for Expose-events.
  * The order of update handling is important:
  * 1. The size must be correct -> UPD_size first
- * 2. The window must be mapped before something is drawn -> UPD_show
+ * 2. Change the position, which might expose part of window -> UPD_pos
  * 3. The XShape must be set before something is drawn -> UPD_mask, UPD_lines
- * 4. Change the position last -> UPD_pos
+ * 4. The window should be mapped before something is drawn -> UPD_show
  * 5. Start the timer last to not account for processing time -> UPD_timer
  * If you change this order, you'll get a broken display. You've been warned!
  */
@@ -263,11 +263,19 @@ event_loop(void *osdv)
     FD_SET(xfd, &readfds);
     FD_SET(osd->pipefd[0], &readfds);
 
+    /* Hide display requested. */
+    if (osd->update & UPD_hide) {
+      DEBUG(Dupdate, "UPD_hide");
+      if (osd->mapped) {
+        XUnmapWindow(osd->display, osd->window);
+        osd->mapped = 0;
+      }
+    }
     /* The font, outline or shadow was changed. Recalculate line height,
      * resize window and bitmaps. */
     if (osd->update & UPD_size) {
       XFontSetExtents *extents = XExtentsOfFontSet(osd->fontset);
-      DEBUG(Dupdate, "UPD_font");
+      DEBUG(Dupdate, "UPD_size");
       osd->extent = &extents->max_logical_extent;
       osd->line_height = osd->extent->height + osd->shadow_offset + 2 *
         osd->outline_offset;
@@ -286,16 +294,33 @@ event_loop(void *osdv)
                                        osd->screen_width, osd->height,
                                        osd->depth);
     }
-    /* Show display requested. */
-    if (osd->update & UPD_show) {
-      DEBUG(Dupdate, "UPD_show");
-      if (!osd->mapped) {
-        osd->mapped = 1;
-        XMapRaised(osd->display, osd->window);
+    /* H/V offset or vertical positon was changed. Horizontal alignment is
+     * handles internally as line realignment with UPD_content. */
+    if (osd->update & UPD_pos) {
+      int x = 0, y = 0;
+      DEBUG(Dupdate, "UPD_pos");
+      switch (osd->align) {
+      case XOSD_left:
+      case XOSD_center:
+        x = osd->screen_xpos + osd->hoffset;
+        break;
+      case XOSD_right:
+        x = osd->screen_xpos - osd->hoffset;
+      }
+      switch (osd->pos) {
+      case XOSD_bottom:
+        y = osd->screen_height - osd->height - osd->voffset;
+        break;
+      case XOSD_middle:
+        y = osd->screen_height / 2 - osd->height - osd->voffset;
+        break;
+      case XOSD_top:
+        y = osd->voffset;
       }
+      XMoveWindow(osd->display, osd->window, x, y);
     }
-    /* The content changed, redraw lines and update XShape unless only colours
-     * where changed. */
+    /* If the content changed, redraw lines in background buffer.
+     * Also update XShape unless only colours were changed. */
     if (osd->update & (UPD_mask | UPD_lines)) {
       DEBUG(Dupdate, "UPD_lines");
       for (line = 0; line < osd->number_lines; line++) {
@@ -320,49 +345,28 @@ event_loop(void *osdv)
           break;
         }
       }
+    }
 #ifndef DEBUG_XSHAPE
-      /* More than colours was changed, update XShape. */
-      if (osd->update & UPD_mask) {
-        DEBUG(Dupdate, "UPD_mask");
-        XShapeCombineMask(osd->display, osd->window, ShapeBounding, 0, 0,
-                          osd->mask_bitmap, ShapeSet);
-      }
-#endif
-      XCopyArea(osd->display, osd->line_bitmap, osd->window, osd->gc, 0, 0,
-                osd->screen_width, osd->height, 0, 0);
+    /* More than colours was changed, also update XShape. */
+    if (osd->update & UPD_mask) {
+      DEBUG(Dupdate, "UPD_mask");
+      XShapeCombineMask(osd->display, osd->window, ShapeBounding, 0, 0,
+                        osd->mask_bitmap, ShapeSet);
     }
-    /* H/V offset or vertical positon was changed. Horizontal alignment is
-     * handles internally as line realignment with UPD_content. */
-    if (osd->update & UPD_pos) {
-      int x = 0, y = 0;
-      DEBUG(Dupdate, "UPD_pos");
-      switch (osd->align) {
-      case XOSD_left:
-      case XOSD_center:
-        x = osd->screen_xpos + osd->hoffset;
-        break;
-      case XOSD_right:
-        x = osd->screen_xpos - osd->hoffset;
-      }
-      switch (osd->pos) {
-      case XOSD_bottom:
-        y = osd->screen_height - osd->height - osd->voffset;
-        break;
-      case XOSD_middle:
-        y = osd->screen_height / 2 - osd->height - osd->voffset;
-        break;
-      case XOSD_top:
-        y = osd->voffset;
+#endif
+    /* Show display requested. */
+    if (osd->update & UPD_show) {
+      DEBUG(Dupdate, "UPD_show");
+      if (!osd->mapped) {
+        osd->mapped = 1;
+        XMapRaised(osd->display, osd->window);
       }
-      XMoveWindow(osd->display, osd->window, x, y);
     }
-    /* Hide display requested. */
-    if (osd->update & UPD_hide) {
-      DEBUG(Dupdate, "UPD_hide");
-      if (osd->mapped) {
-        XUnmapWindow(osd->display, osd->window);
-        osd->mapped = 0;
-      }
+    /* Copy content, if window was changed or exposed. */
+    if (osd->mapped && osd->update & (UPD_size | UPD_pos | UPD_lines | UPD_show)) {
+      DEBUG(Dupdate, "UPD_copy");
+      XCopyArea(osd->display, osd->line_bitmap, osd->window, osd->gc, 0, 0,
+                osd->screen_width, osd->height, 0, 0);
     }
     /* Flush all pennding X11 requests, if any. */
     if (osd->update & ~UPD_timer) {
